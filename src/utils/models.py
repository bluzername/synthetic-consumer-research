"""Pydantic data models for the Product Ideation System."""

from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field
from enum import Enum


class DisappointmentLevel(str, Enum):
    """Level of disappointment if product becomes unavailable."""
    VERY = "VERY"
    SOMEWHAT = "SOMEWHAT"
    NOT = "NOT"


class ProductConcept(BaseModel):
    """Structured product concept generated by Ideator agent."""
    name: str = Field(description="Product name")
    tagline: str = Field(description="One-sentence value proposition")
    target_market: str = Field(description="Primary customer segment")
    problem_solved: str = Field(description="Core pain point addressed")
    features: List[str] = Field(description="Key features (3-5)")
    differentiators: List[str] = Field(description="Competitive advantages")
    pricing_model: str = Field(description="Suggested pricing approach")
    
    def to_summary(self) -> str:
        """Generate a text summary of the concept."""
        return f"""
Product: {self.name}
Tagline: {self.tagline}
Target Market: {self.target_market}
Problem: {self.problem_solved}
Features: {', '.join(self.features)}
Differentiators: {', '.join(self.differentiators)}
Pricing: {self.pricing_model}
""".strip()


class Persona(BaseModel):
    """Synthetic consumer persona for market simulation."""
    name: str = Field(description="Persona name")
    age: int = Field(description="Age in years", ge=18, le=100)
    occupation: str = Field(description="Job/occupation")
    income_bracket: str = Field(description="Income level")
    location_type: str = Field(description="Urban/suburban/rural")
    tech_savviness: int = Field(description="Tech comfort level 1-5", ge=1, le=5)
    values: List[str] = Field(description="Core values (2-3)")
    pain_points: List[str] = Field(description="Main pain points (2-3)")
    personality_traits: str = Field(description="Big Five profile summary")
    shopping_behavior: str = Field(description="How they make purchase decisions")
    
    def to_prompt_context(self) -> Dict[str, Any]:
        """Convert persona to context for prompts."""
        return {
            "persona_name": self.name,
            "persona_age": self.age,
            "persona_occupation": self.occupation,
            "persona_income": self.income_bracket,
            "persona_values": ", ".join(self.values),
            "persona_pain_points": ", ".join(self.pain_points),
            "persona_tech_level": self.tech_savviness,
            "persona_personality": self.personality_traits,
        }


class PersonaResponse(BaseModel):
    """Market response from a single persona using SSR methodology.
    
    Instead of directly extracting Likert scores (which the paper advises against),
    we capture natural language responses and later use Semantic Similarity Rating (SSR)
    to convert them into probability distributions over the Likert scale.
    """
    persona_name: str = Field(description="Which persona responded")
    
    # Natural language responses (for SSR conversion)
    interest_response: str = Field(description="Natural language response about interest level")
    disappointment_response: str = Field(description="Natural language response about disappointment if unavailable")
    recommendation_response: str = Field(description="Natural language response about likelihood to recommend")
    
    # Qualitative feedback
    main_benefit: str = Field(description="Primary benefit they see")
    concerns: List[str] = Field(description="Top concerns/hesitations")


class MarketSegmentation(BaseModel):
    """Market segmentation analysis."""
    superfans_pct: float = Field(description="% with 5/5 interest + VERY disappointed (target market)")
    enthusiasts_pct: float = Field(description="% with 4-5/5 interest (early adopters)")
    interested_pct: float = Field(description="% with 3/5 interest (early majority)")
    skeptical_pct: float = Field(description="% with 1-2/5 interest (not target market)")
    
    # Disappointment distribution
    very_disappointed_pct: float = Field(description="% VERY disappointed")
    somewhat_disappointed_pct: float = Field(description="% SOMEWHAT disappointed")
    not_disappointed_pct: float = Field(description="% NOT disappointed")
    
    # Recommendation distribution
    promoters_pct: float = Field(description="% promoters (9-10/10)")
    passives_pct: float = Field(description="% passives (7-8/10)")
    detractors_pct: float = Field(description="% detractors (0-6/10)")


class MarketFitScore(BaseModel):
    """Product-Market Fit analysis results with enhanced metrics.
    
    Enhanced metrics prioritize superfan identification and market segmentation
    over traditional 40% PMF threshold, which is often unrealistic for early-stage concepts.
    
    Key insight: 10%+ superfans = viable niche product (more important than 40% lukewarm interest)
    """
    # Core metrics
    pmf_score: float = Field(description="% very disappointed (Sean Ellis - for comparison, but see superfan_ratio for better early-stage metric)")
    avg_interest: float = Field(description="Average interest score (1-5)")
    nps: int = Field(description="Net Promoter Score (-100 to +100)")
    
    # Enhanced segmentation (PRIMARY METRICS for early-stage validation)
    segmentation: MarketSegmentation = Field(description="Detailed market segments - use this for strategic decisions")
    
    # Target market viability (KEY METRICS)
    target_market_size_pct: float = Field(description="% who are target market (superfans + enthusiasts) - aim for 25%+")
    superfan_ratio: float = Field(description="Ratio of superfans to total (PRIMARY VIABILITY INDICATOR: â‰¥0.10 = viable niche)")
    
    # Interest distribution (for visualization)
    interest_distribution: Dict[int, int] = Field(description="Count by interest level 1-5")
    
    # Strategic insights
    top_benefits: List[str] = Field(description="Most mentioned benefits")
    top_concerns: List[str] = Field(description="Most mentioned concerns")
    recommendation: str = Field(description="Strategic recommendation based on enhanced metrics")
    business_model_fit: str = Field(description="Suggested business model based on market segments")
    total_responses: int = Field(description="Number of personas surveyed")
    
    def meets_threshold(self, threshold: float = 40.0) -> bool:
        """Check if PMF score meets the threshold (legacy compatibility)."""
        return self.pmf_score >= threshold
    
    def is_viable_niche(self) -> bool:
        """Check if product is viable as a niche product (10%+ superfans)."""
        return self.superfan_ratio >= 0.10
    
    def is_viable_mass_market(self) -> bool:
        """Check if product has mass market potential (40%+ enthusiasts)."""
        return self.segmentation.enthusiasts_pct >= 40.0
    
    def get_market_strategy(self) -> str:
        """Get recommended market strategy based on segmentation."""
        if self.superfan_ratio >= 0.10:
            if self.segmentation.enthusiasts_pct >= 40:
                return "MASS MARKET: Broad appeal with strong core - scale aggressively"
            else:
                return "NICHE FIRST: Strong core audience - nail the niche, then expand"
        else:
            if self.segmentation.interested_pct >= 50:
                return "REFINE: Moderate interest but no passion - iterate on value prop"
            else:
                return "PIVOT: Weak market fit - consider major changes or new market"
    
    def get_rating(self) -> str:
        """Get qualitative rating based on multiple factors.
        
        Uses enhanced metrics that prioritize superfan identification over
        traditional PMF threshold, which is often unrealistic for concepts.
        """
        if self.is_viable_mass_market():
            return "EXCELLENT (MASS MARKET)"
        elif self.is_viable_niche():
            return "GOOD (VIABLE NICHE)"
        elif self.segmentation.interested_pct >= 40:
            return "FAIR (NEEDS REFINEMENT)"
        else:
            return "POOR (PIVOT NEEDED)"
    
    def get_viability_summary(self) -> Dict[str, Any]:
        """Get comprehensive viability summary with key metrics.
        
        Returns all critical metrics for decision-making in one place.
        """
        return {
            "viable": self.is_viable_niche() or self.is_viable_mass_market(),
            "rating": self.get_rating(),
            "superfan_ratio": f"{self.superfan_ratio:.1%}",
            "target_market_size": f"{self.target_market_size_pct:.1f}%",
            "strategy": self.get_market_strategy(),
            "business_model": self.business_model_fit,
            "key_strength": self.top_benefits[0] if self.top_benefits else "N/A",
            "key_concern": self.top_concerns[0] if self.top_concerns else "N/A",
            "meets_traditional_pmf": self.meets_threshold(40.0),
            "pmf_score": f"{self.pmf_score:.1f}%",
            "nps": self.nps,
        }
    
    def should_proceed(self) -> bool:
        """Determine if concept should proceed to development.
        
        Uses enhanced criteria: viable if 10%+ superfans OR 40%+ enthusiasts,
        regardless of traditional 40% PMF threshold.
        """
        return self.is_viable_niche() or self.is_viable_mass_market()


class CriticFeedback(BaseModel):
    """Feedback from Critic agent for concept refinement."""
    strengths_to_amplify: List[str] = Field(description="What's working well")
    critical_gaps: List[str] = Field(description="What needs improvement")
    specific_refinements: Dict[str, List[str]] = Field(
        description="Actionable changes by category"
    )
    strategic_direction: str = Field(description="Overall strategy recommendation")
    
    def to_refinement_prompt(self) -> str:
        """Convert feedback to prompt for Ideator refinement."""
        feedback = "**Strengths to Amplify:**\n"
        for strength in self.strengths_to_amplify:
            feedback += f"- {strength}\n"
        
        feedback += "\n**Critical Gaps to Address:**\n"
        for gap in self.critical_gaps:
            feedback += f"- {gap}\n"
        
        feedback += "\n**Specific Refinements:**\n"
        for category, changes in self.specific_refinements.items():
            feedback += f"\n{category}:\n"
            for change in changes:
                feedback += f"- {change}\n"
        
        feedback += f"\n**Strategic Direction:** {self.strategic_direction}"
        
        return feedback


class WorkflowState(BaseModel):
    """State object for LangGraph workflow."""
    model_config = {"arbitrary_types_allowed": True}
    
    seed_idea: str
    current_concept: Optional[ProductConcept] = None
    personas: List[Persona] = Field(default_factory=list)
    persona_responses: List[PersonaResponse] = Field(default_factory=list)
    market_fit: Optional[MarketFitScore] = None
    critic_feedback: Optional[CriticFeedback] = None
    iteration: int = 0
    max_iterations: int = 5
    pmf_threshold: float = 40.0
    history: List[Dict[str, Any]] = Field(default_factory=list)
    
    def add_to_history(self, iteration: int, concept: ProductConcept, pmf: MarketFitScore):
        """Add iteration to history."""
        self.history.append({
            "iteration": iteration,
            "product_name": concept.name,
            "pmf_score": pmf.pmf_score,
            "nps": pmf.nps,
            "avg_interest": pmf.avg_interest,
        })
    
    def should_continue(self) -> bool:
        """Check if workflow should continue iterating."""
        if self.market_fit is None:
            return True
        
        # Stop if PMF threshold met
        if self.market_fit.meets_threshold(self.pmf_threshold):
            return False
        
        # Stop if max iterations reached
        if self.iteration >= self.max_iterations:
            return False
        
        return True


class SocialMediaPost(BaseModel):
    """Formatted social media post."""
    platform: str = Field(description="Platform name (x, linkedin)")
    text: str = Field(description="Post text content")
    char_count: int = Field(description="Character count")
    image_paths: List[str] = Field(description="Paths to images")
    hashtags: List[str] = Field(default_factory=list, description="Hashtags used")
    
    def is_within_limit(self, limit: int) -> bool:
        """Check if post is within character limit."""
        return self.char_count <= limit


class OutputPackage(BaseModel):
    """Complete output package metadata."""
    product_name: str
    timestamp: str
    output_dir: str
    concept: ProductConcept
    market_fit: MarketFitScore
    iterations: int
    total_personas: int
    posts: List[SocialMediaPost]
    image_files: List[str]
    analytics_files: List[str]


class APICallLog(BaseModel):
    """Log entry for API calls (cost tracking)."""
    timestamp: str
    model: str
    operation: str
    input_tokens: Optional[int] = None
    output_tokens: Optional[int] = None
    estimated_cost: Optional[float] = None
    success: bool = True
    error_message: Optional[str] = None

